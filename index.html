<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FunnyImageAI — Safari-ready (image + video/audio voice)</title>

  <!-- TensorFlow.js + MobileNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.2.1/dist/mobilenet.min.js"></script>

  <style>
    :root{--accent:#0b6df2;--muted:#6b7280;--card:#fff;--bg:#f3f6fb;--radius:10px}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;background:var(--bg);color:#0f172a}
    .wrap{max-width:1100px;margin:18px auto;padding:16px}
    header{display:flex;justify-content:space-between;align-items:center;gap:16px;margin-bottom:14px}
    h1{margin:0;font-size:1.25rem}
    .muted{color:var(--muted);font-size:0.95rem}
    .badge{background:#e9f2ff;color:var(--accent);padding:6px 10px;border-radius:999px;font-weight:600;border:1px solid #dbeafe}
    .grid{display:grid;grid-template-columns:1fr 380px;gap:12px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:var(--radius);padding:12px;box-shadow:0 6px 18px rgba(12,18,36,0.06)}
    .uploader{display:flex;flex-direction:column;align-items:center;justify-content:center;border:2px dashed #dbeafe;border-radius:10px;padding:14px;background:linear-gradient(180deg,#fff,#fbfdff)}
    .hidden{display:none}
    .preview{max-width:100%;border-radius:8px;margin-top:10px}
    label{display:block;font-weight:700;margin-bottom:6px}
    select,input,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid #e5e7eb;background:#fff;box-sizing:border-box}
    textarea{min-height:80px;resize:vertical}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:var(--accent);color:#fff;border:none;padding:9px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;color:var(--accent);border:1px solid var(--accent)}
    button.secondary{background:#6b7280}
    .pred-list{list-style:none;padding:0;margin:12px 0}
    .pred-list li{padding:8px 6px;border-bottom:1px dashed #f1f5f9}
    .small{font-size:0.9rem;color:var(--muted)}
    .clip-list li{margin-bottom:6px}
    .thumb{width:84px;height:64px;object-fit:cover;border-radius:8px;border:1px solid #eef2ff}
    footer{margin-top:16px;color:var(--muted);text-align:center}
    .inline{display:inline-flex;gap:8px;align-items:center}
    .status { margin-left:8px; font-weight:600; color:var(--muted); font-size:0.95rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>FunnyImageAI — Safari-ready</h1>
        <div class="muted">One image for guessing. Use a video or upload an audio clip for voice. Tap "Enable audio" once (Safari needs a gesture).</div>
      </div>
      <div style="text-align:right">
        <div class="badge" id="pointsBadge">Points: 0</div>
        <div style="margin-top:8px">
          <button id="enableAudioBtn" class="ghost">Enable audio</button>
          <div id="audioStatus" class="small muted" style="margin-top:6px">Audio: not enabled</div>
        </div>
      </div>
    </header>

    <div class="grid">
      <!-- Left: main interaction -->
      <div class="card">
        <label>Single image (for guessing)</label>
        <div class="uploader" id="imageUploader">
          <input id="imageInput" type="file" accept="image/*">
          <button id="pickImageBtn" class="ghost">Choose Image</button>
          <div class="small muted" style="margin-top:8px">Or drag & drop an image here</div>
          <img id="imagePreview" class="preview hidden" alt="Image preview">
        </div>

        <div id="modelStatus" class="small" style="margin-top:12px">Loading MobileNet model...</div>

        <div id="predictionsArea" class="hidden">
          <label style="margin-top:10px">AI guesses (top 3)</label>
          <ul id="predList" class="pred-list"></ul>

          <div class="controls">
            <button id="correctBtn">AI correct</button>
            <button id="incorrectBtn" class="secondary">AI incorrect (save label)</button>
            <button id="speakBtn" class="ghost">Speak top guess</button>
          </div>

          <div id="labelSaveArea" class="hidden" style="margin-top:10px">
            <input id="correctLabelInput" placeholder="Correct label (exact)">
            <div class="controls" style="margin-top:8px">
              <button id="saveLabelBtn">Save labeled image</button>
              <button id="cancelSaveBtn" class="ghost">Cancel</button>
            </div>
          </div>

          <hr style="margin:12px 0">

          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="startLoopBtn" class="u-btn">Start auto-guesses</button>
            <button id="stopLoopBtn" class="u-btn ghost" style="display:none">Stop</button>
            <div style="display:flex;gap:8px;align-items:center">
              <label class="small muted">Delay (sec)</label>
              <input id="minDelay" type="number" min="1" value="2" style="width:70px">
              <span class="small muted">to</span>
              <input id="maxDelay" type="number" min="1" value="5" style="width:70px">
            </div>
            <div class="status" id="loopStatus">Stopped</div>
          </div>
        </div>

        <hr style="margin:14px 0">

        <label>Saved clips</label>
        <ul id="clipList" class="clip-list small"></ul>

        <div style="margin-top:10px" class="small">Use the Voice Maker (right) to edit templates and include <code>{clip:name}</code> or <code>{label}</code>.</div>
      </div>

      <!-- Right: video/audio, voice maker -->
      <div>
        <div class="card" style="margin-bottom:12px">
          <label>Video (voice source) — OR upload audio (fallback for Safari)</label>
          <input id="videoInput" type="file" accept="video/*">
          <video id="videoPlayer" controls style="width:100%;margin-top:8px;display:none"></video>

          <div style="margin-top:8px" class="small">
            <div id="audioFallbackArea" class="hidden">
              <label>Audio fallback (if video extraction not supported)</label>
              <input id="audioInput" type="file" accept="audio/*">
              <div class="small muted">Upload a short MP3/WAV if the browser cannot record from video.</div>
            </div>

            <label style="margin-top:8px">Segment to extract (seconds)</label>
            <div style="display:flex;gap:8px">
              <input id="segStart" placeholder="start (s)" type="number" min="0" step="0.1">
              <input id="segEnd" placeholder="end (s)" type="number" min="0" step="0.1">
            </div>

            <div class="controls" style="margin-top:8px">
              <button id="extractClipBtn">Extract clip & Match voice</button>
              <button id="previewSegBtn" class="ghost">Preview segment</button>
            </div>

            <div id="extractStatus" class="small muted" style="margin-top:8px"></div>
          </div>
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Voice Maker</strong>
            <span class="small muted">Templates use <code>{label}</code> and <code>{clip:name}</code></span>
          </div>

          <label style="margin-top:10px">Choose script</label>
          <select id="vmScriptList"></select>

          <label style="margin-top:8px">Script name</label>
          <input id="vmName">

          <label style="margin-top:8px">Templates (one per line)</label>
          <textarea id="vmTemplates"></textarea>

          <label style="margin-top:8px">Suggested pitch</label>
          <input id="vmPitch" type="number" step="0.1" min="0" max="2" value="1.0">

          <label style="margin-top:8px">Suggested rate</label>
          <input id="vmRate" type="number" step="0.1" min="0.5" max="2" value="1.0">

          <div style="margin-top:8px; display:flex; gap:8px">
            <button id="vmSave">Save script</button>
            <button id="vmNew" class="ghost">New</button>
            <button id="vmDelete" class="secondary">Delete</button>
          </div>

          <div style="margin-top:12px" class="small muted">When you extract a clip, the app will suggest pitch & rate; save them with a script so TTS segments use those settings.</div>
        </div>
      </div>
    </div>

    <footer>
      <div class="small muted">All processing is client-side. If extraction fails on Safari, use the audio upload fallback.</div>
    </footer>
  </div>

<script>
/* Safari-focused robust implementation
   - Ensure user taps "Enable audio" to allow speech on Safari (user gesture)
   - Robust voice loading + speakText (waits for voices and doesn't cancel)
   - If captureStream/MediaRecorder unavailable, show audio-file fallback
   - Auto-guess loop waits for audio enabled before speaking
*/

// Storage keys & defaults
const SCRIPTS_KEY = 'funny_safari_scripts_v1';
const CLIPS_KEY = 'funny_safari_clips_v1';
const DATASET_KEY = 'funny_safari_dataset_v1';
const POINTS_KEY = 'funny_safari_points_v1';

function defaultScripts(){
  return {
    "Shy": { templates: ["Um... I think this might be {label}."], pitch:1.0, rate:1.0 },
    "Sarcastic": { templates: ["{label}? Yeah, right. Maybe."], pitch:1.0, rate:0.95 },
    "Confident": { templates: ["I'm pretty sure this is {label}."], pitch:1.0, rate:1.1 }
  };
}
function loadScripts(){ try { const raw = localStorage.getItem(SCRIPTS_KEY); return raw ? JSON.parse(raw) : defaultScripts(); } catch(e){ return defaultScripts(); } }
function saveScripts(s){ localStorage.setItem(SCRIPTS_KEY, JSON.stringify(s)); }
function loadClips(){ try { return JSON.parse(localStorage.getItem(CLIPS_KEY) || '{}'); } catch(e){ return {}; } }
function saveClips(c){ localStorage.setItem(CLIPS_KEY, JSON.stringify(c)); }
function loadDataset(){ try { return JSON.parse(localStorage.getItem(DATASET_KEY) || '{}'); } catch(e){ return {}; } }
function saveDataset(d){ localStorage.setItem(DATASET_KEY, JSON.stringify(d)); }
function loadPoints(){ return parseInt(localStorage.getItem(POINTS_KEY) || '0', 10); }
function savePoints(n){ localStorage.setItem(POINTS_KEY, String(n)); updatePointsBadge(); }
function updatePointsBadge(){ document.getElementById('pointsBadge').textContent = 'Points: ' + loadPoints(); }

// Model
let net = null;
async function loadModel(){
  document.getElementById('modelStatus').textContent = 'Loading MobileNet model (from CDN)...';
  try {
    net = await mobilenet.load({version:2, alpha:1.0});
    document.getElementById('modelStatus').textContent = 'Model loaded.';
  } catch(e) {
    document.getElementById('modelStatus').textContent = 'Model failed to load: ' + (e.message || e);
  }
}

// Voice system: robust loading for Safari
let AVAILABLE_VOICES = [];
let VOICES_READY = false;
let audioEnabled = false; // user must click enableAudioBtn

function ensureVoicesLoaded(timeoutMs = 1500) {
  return new Promise((resolve) => {
    const v = window.speechSynthesis.getVoices();
    if (v && v.length) {
      AVAILABLE_VOICES = v;
      VOICES_READY = true;
      return resolve(v);
    }
    const onvoices = () => {
      const vv = window.speechSynthesis.getVoices();
      AVAILABLE_VOICES = vv;
      VOICES_READY = true;
      window.speechSynthesis.removeEventListener('voiceschanged', onvoices);
      resolve(vv);
    };
    window.speechSynthesis.addEventListener('voiceschanged', onvoices);
    setTimeout(() => {
      const vv = window.speechSynthesis.getVoices() || [];
      AVAILABLE_VOICES = vv;
      VOICES_READY = AVAILABLE_VOICES.length > 0;
      window.speechSynthesis.removeEventListener('voiceschanged', onvoices);
      resolve(AVAILABLE_VOICES);
    }, timeoutMs);
  });
}

function pickVoiceIndex(preferredIndex = null) {
  if (preferredIndex !== null && !isNaN(preferredIndex) && AVAILABLE_VOICES[preferredIndex]) return preferredIndex;
  for (let i = 0; i < AVAILABLE_VOICES.length; i++) {
    const v = AVAILABLE_VOICES[i];
    if (/en/i.test(v.lang) || /english/i.test(v.name)) return i;
  }
  return AVAILABLE_VOICES.length ? 0 : null;
}

async function speakText(text, rate = 1.0, pitch = 1.0, preferredVoiceIndex = null) {
  if (!audioEnabled) {
    console.warn('Audio not enabled by user gesture; speak suppressed (Safari requires user gesture).');
    return;
  }
  if (!('speechSynthesis' in window)) {
    console.warn('No speechSynthesis available');
    return;
  }
  await ensureVoicesLoaded();
  return new Promise((resolve) => {
    try {
      const utter = new SpeechSynthesisUtterance(String(text));
      utter.rate = Number.isFinite(rate) ? rate : 1.0;
      utter.pitch = Number.isFinite(pitch) ? pitch : 1.0;
      const idx = pickVoiceIndex(preferredVoiceIndex);
      if (idx !== null && AVAILABLE_VOICES[idx]) utter.voice = AVAILABLE_VOICES[idx];
      utter.onend = () => resolve();
      utter.onerror = () => resolve();
      // speak (do not cancel global synthesis — sequential behavior is handled by awaiting)
      window.speechSynthesis.speak(utter);
    } catch (err) {
      console.warn('speakText failed', err);
      resolve();
    }
  });
}

// Playback utilities
function playClipDataUrl(dataUrl){ return new Promise(res => { const audio = new Audio(dataUrl); audio.onended = ()=>res(); audio.onerror = ()=>res(); audio.play().catch(()=>res()); }); }

function buildSequenceFromTemplate(template, label){
  const seq = []; const clipRegex = /\{clip:([^}]+)\}/g;
  let lastIndex = 0; let m;
  while((m = clipRegex.exec(template)) !== null){
    const before = template.slice(lastIndex, m.index);
    if(before.trim()) seq.push({type:'tts', text: before.replace(/\{label\}/g, label)});
    const clipName = m[1].trim();
    seq.push({type:'clip', clip: clipName});
    lastIndex = m.index + m[0].length;
  }
  const tail = template.slice(lastIndex);
  if(tail.trim()) seq.push({type:'tts', text: tail.replace(/\{label\}/g, label)});
  return seq;
}

async function playSequence(seq, rate=1.0, pitch=1.0){
  for(const item of seq){
    if(item.type === 'clip'){
      const clips = loadClips();
      const dataUrl = clips[item.clip];
      if(dataUrl) await playClipDataUrl(dataUrl);
      else await new Promise(r=>setTimeout(r,120));
    } else if(item.type === 'tts'){
      const t = (item.text||'').trim();
      if(t) await speakText(t, rate, pitch);
      else await new Promise(r=>setTimeout(r,80));
    }
  }
}

// small "funny badness"
function applySmallBadness(preds){
  const commons = ["banana","chair","shoe","cat","dog","tree","car","clock","bottle","cup","box"];
  let labels = preds.map(p=>[p[0], p[1]]);
  if(Math.random() < 0.35){
    const fake = commons[Math.floor(Math.random()*commons.length)];
    labels[0] = [fake, 0.10 + Math.random()*0.08];
    for(let i=1;i<labels.length;i++) labels[i][1] = Math.max(0.01, labels[i][1]*0.6);
  } else {
    labels = labels.map(([lbl,score]) => [lbl, Math.max(0.05, score*0.5)]);
  }
  if(Math.random() < 0.25 && labels.length > 2){
    const tmp = labels[1]; labels[1] = labels[2]; labels[2] = tmp;
  }
  return labels;
}

// Pitch estimation (basic autocorrelation; best-effort)
async function estimatePitchFromAudioBuffer(audioBuffer){
  const fs = audioBuffer.sampleRate;
  const channelData = audioBuffer.getChannelData(0);
  const N = Math.min(channelData.length, fs);
  const buf = channelData.subarray(0, N);
  let bestOffset = -1;
  let bestCorr = 0;
  for(let offset = 20; offset < 1000; offset++){
    let corr = 0;
    for(let i=0; i < N - offset; i++){
      corr += Math.abs(buf[i] - buf[i+offset]);
    }
    const val = 1.0 / (1 + corr);
    if(val > bestCorr){ bestCorr = val; bestOffset = offset; }
  }
  if(bestOffset <= 0) return null;
  const fundamental = fs / bestOffset;
  return fundamental;
}

// Audio extraction paths
async function extractAudioFromVideoSegment(videoElement, startSec, endSec){
  // Prefer captureStream + MediaRecorder if available
  if(videoElement.captureStream && typeof MediaRecorder !== 'undefined'){
    // previous robust approach
    let recorder;
    const stream = videoElement.captureStream();
    try { recorder = new MediaRecorder(stream, {mimeType: 'audio/webm;codecs=opus'}); } catch(e) { recorder = new MediaRecorder(stream); }
    const chunks = [];
    recorder.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    return new Promise((resolve, reject) => {
      recorder.onstop = async () => {
        try {
          const blob = new Blob(chunks, {type: chunks[0]?.type || 'audio/webm'});
          const arrayBuf = await blob.arrayBuffer();
          let audioBuffer;
          try {
            audioBuffer = await new Promise((res, rej) => {
              const ctx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100 * 2, 44100);
              ctx.decodeAudioData(arrayBuf, decoded => res(decoded), err => rej(err));
            });
          } catch(err){
            const actx = new (window.AudioContext || window.webkitAudioContext)();
            audioBuffer = await actx.decodeAudioData(arrayBuf);
          }
          const dataUrl = URL.createObjectURL(blob);
          resolve({blob, dataUrl, audioBuffer});
        } catch(e){ reject(e); }
      };
      recorder.onerror = err => reject(err);
      const onSeeked = () => {
        videoElement.play();
        recorder.start();
        const stopHandler = () => {
          if(videoElement.currentTime >= endSec - 0.01 || videoElement.ended){
            videoElement.pause();
            setTimeout(()=> { try { recorder.stop(); } catch(e){} }, 150);
            videoElement.removeEventListener('timeupdate', stopHandler);
          }
        };
        videoElement.addEventListener('timeupdate', stopHandler);
      };
      videoElement.currentTime = Math.max(0, startSec);
      videoElement.addEventListener('seeked', function f(){
        videoElement.removeEventListener('seeked', f);
        onSeeked();
      });
    });
  } else {
    // captureStream not supported: fail early and suggest audio upload fallback
    throw new Error('Video extraction not supported in this browser. Use the audio upload fallback instead.');
  }
}

// Decode audio file directly (used for audio fallback upload)
async function decodeAudioFileToBuffer(file){
  const arrayBuf = await file.arrayBuffer();
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  return await ctx.decodeAudioData(arrayBuf);
}

// UI wiring and state
let currentImageEl = null;
let lastPredictions = [];
let guessLoopRunning = false;
let guessCandidates = [];
let guessIndex = 0;
let lastGuessed = null;

function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function buildGuessCandidatesFromPreds(preds){
  const commons = ["banana","chair","shoe","cat","dog","tree","car","clock","bottle","cup","box"];
  const labels = preds.map(p=>p[0]);
  let combined = labels.slice();
  commons.forEach(c => { if(!combined.includes(c) && combined.length < Math.max(6, labels.length+3)) combined.push(c); });
  return shuffleArray(combined);
}

async function startGuessLoop(){
  if(guessLoopRunning) return;
  if(!lastPredictions || lastPredictions.length === 0){ alert('No predictions yet — upload an image first.'); return; }
  if(!audioEnabled){ alert('Tap "Enable audio" before starting auto-guesses (Safari requires a user gesture).'); return; }
  guessCandidates = buildGuessCandidatesFromPreds(lastPredictions);
  guessIndex = 0;
  guessLoopRunning = true;
  document.getElementById('startLoopBtn').style.display = 'none';
  document.getElementById('stopLoopBtn').style.display = '';
  document.getElementById('loopStatus').textContent = 'Running';
  while(guessLoopRunning){
    if(guessIndex >= guessCandidates.length){
      guessCandidates = shuffleArray(guessCandidates.slice());
      guessIndex = 0;
    }
    let g = guessCandidates[guessIndex++];
    if(g === lastGuessed && guessCandidates.length > 1){
      g = guessCandidates[guessIndex++ % guessCandidates.length];
    }
    lastGuessed = g;
    const scriptName = document.getElementById('vmScriptList').value;
    const script = loadScripts()[scriptName] || null;
    const tpl = script ? script.templates[Math.floor(Math.random()*script.templates.length)] : 'I think this is {label}.';
    const seq = buildSequenceFromTemplate(tpl, g);
    const pitch = script ? (script.pitch||1.0) : 1.0;
    const rate = script ? (script.rate||1.0) : 1.0;
    await playSequence(seq, rate, pitch);
    if(!guessLoopRunning) break;
    // delay
    let minD = parseFloat(document.getElementById('minDelay').value) || 2;
    let maxD = parseFloat(document.getElementById('maxDelay').value) || 5;
    if(maxD < minD) { const t=minD; minD=maxD; maxD=t; }
    const delaySec = minD + Math.random()*(maxD - minD);
    const start = Date.now();
    while(guessLoopRunning && Date.now()-start < delaySec*1000){
      await new Promise(r=>setTimeout(r, 200));
    }
  }
  guessLoopRunning = false;
  document.getElementById('startLoopBtn').style.display = '';
  document.getElementById('stopLoopBtn').style.display = 'none';
  document.getElementById('loopStatus').textContent = 'Stopped';
}

function stopGuessLoop(){ guessLoopRunning = false; }

// UI helpers
function renderPredictions(preds){
  const ul = document.getElementById('predList'); ul.innerHTML = '';
  preds.forEach((p,i)=>{ const li = document.createElement('li'); li.innerHTML = `<strong>${i+1}. ${escapeHtml(String(p[0]))}</strong> — ${(p[1]*100).toFixed(1)}%`; ul.appendChild(li); });
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function populateUI(){
  const scripts = loadScripts();
  const vm = document.getElementById('vmScriptList');
  vm.innerHTML = '';
  Object.keys(scripts).sort().forEach(name => {
    const o = document.createElement('option'); o.value = name; o.textContent = name; vm.appendChild(o);
  });
  if(vm.options.length) vm.value = vm.options[0].value;
  loadScriptEditor();
  refreshClipList();
  updatePointsBadge();
}

function loadScriptEditor(){
  const name = document.getElementById('vmScriptList').value;
  const scripts = loadScripts();
  if(!name || !scripts[name]) return;
  const v = scripts[name];
  document.getElementById('vmName').value = name;
  document.getElementById('vmTemplates').value = (v.templates || []).join('\n');
  document.getElementById('vmPitch').value = v.pitch || 1.0;
  document.getElementById('vmRate').value = v.rate || 1.0;
}

function refreshClipList(){
  const list = document.getElementById('clipList');
  list.innerHTML = '';
  const clips = loadClips();
  const names = Object.keys(clips).sort();
  if(names.length === 0){ list.innerHTML = '<li class="small muted">No clips saved yet.</li>'; return; }
  names.forEach(n=>{
    const li = document.createElement('li');
    li.innerHTML = `<strong>${escapeHtml(n)}</strong> — <a href="#" data-play="${n}">Play</a> <a href="#" data-del="${n}" style="color:#ef4444;margin-left:8px">Delete</a>`;
    list.appendChild(li);
  });
  list.querySelectorAll('[data-play]').forEach(a=>{
    a.addEventListener('click', ev=>{
      ev.preventDefault();
      const k = a.getAttribute('data-play');
      const clips = loadClips();
      const url = clips[k];
      if(url){ const audio = new Audio(url); audio.play(); }
    });
  });
  list.querySelectorAll('[data-del]').forEach(a=>{
    a.addEventListener('click', ev=>{
      ev.preventDefault();
      const k = a.getAttribute('data-del');
      if(!confirm('Delete clip '+k+'?')) return;
      const clips = loadClips(); delete clips[k]; saveClips(clips); refreshClipList();
    });
  });
}

// DOM events & wiring
document.addEventListener('DOMContentLoaded', async ()=>{
  if(!localStorage.getItem(SCRIPTS_KEY)) saveScripts(defaultScripts());
  populateUI();
  loadModel();

  // Audio enable (Safari gesture)
  document.getElementById('enableAudioBtn').addEventListener('click', async ()=>{
    // mark enabled and attempt to load voices and speak a short confirmation
    audioEnabled = true;
    document.getElementById('audioStatus').textContent = 'Audio: enabled';
    await ensureVoicesLoaded(2000);
    // Play a short confirmation phrase (user gesture now satisfied)
    try { await speakText('Audio enabled', 1.0, 1.0); } catch(e){ console.warn(e); }
  });

  // Video/audio fallback detection
  const supportsCapture = !!HTMLVideoElement.prototype.captureStream && typeof MediaRecorder !== 'undefined';
  if(!supportsCapture){
    document.getElementById('audioFallbackArea').classList.remove('hidden');
    document.getElementById('extractStatus').textContent = 'Video extraction not supported — use audio upload.';
  }

  // Image input
  document.getElementById('pickImageBtn').addEventListener('click', ()=> document.getElementById('imageInput').click());
  document.getElementById('imageInput').addEventListener('change', async (ev)=>{
    const f = ev.target.files && ev.target.files[0]; if(!f) return;
    try {
      const imgEl = await new Promise((res,rej)=>{
        const url = URL.createObjectURL(f);
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
        img.onerror = rej;
        img.src = url;
      });
      currentImageEl = imgEl;
      document.getElementById('imagePreview').src = imgEl.src;
      document.getElementById('imagePreview').classList.remove('hidden');
      // stop loop if running
      if(guessLoopRunning) stopGuessLoop();
      // classify with model (ensure loaded)
      if(!net) await loadModel();
      document.getElementById('modelStatus').textContent = 'Classifying...';
      const raw = await net.classify(imgEl, 3);
      const preds = raw.map(r => [r.className, r.probability]);
      lastPredictions = applySmallBadness(preds);
      renderPredictions(lastPredictions);
      document.getElementById('predictionsArea').classList.remove('hidden');
      document.getElementById('modelStatus').textContent = 'Ready';
      // auto speak one time if user enabled audio and toggle could be used (we keep previous auto behavior off to avoid surprises)
      if(audioEnabled && document.getElementById('autoSpeakToggle') && document.getElementById('autoSpeakToggle').checked){
        const scriptName = document.getElementById('vmScriptList').value;
        const script = loadScripts()[scriptName] || null;
        const tpl = script ? script.templates[Math.floor(Math.random()*script.templates.length)] : 'I think this is {label}.';
        const seq = buildSequenceFromTemplate(tpl, lastPredictions[0] ? lastPredictions[0][0] : 'something');
        const pitch = script ? (script.pitch||1.0) : 1.0;
        const rate = script ? (script.rate||1.0) : 1.0;
        await playSequence(seq, rate, pitch);
      }
    } catch(err){
      alert('Image load/classify failed: ' + (err.message || err));
    }
  });

  // Manual speak
  document.getElementById('speakBtn').addEventListener('click', async ()=>{
    if(!lastPredictions || !lastPredictions[0]){ alert('No prediction'); return; }
    if(!audioEnabled){ alert('Tap "Enable audio" to allow speech in this browser.'); return; }
    const top = lastPredictions[0][0];
    const scriptName = document.getElementById('vmScriptList').value;
    const script = loadScripts()[scriptName] || null;
    const tpl = script ? script.templates[Math.floor(Math.random()*script.templates.length)] : 'I think this is {label}.';
    const seq = buildSequenceFromTemplate(tpl, top);
    const pitch = script ? (script.pitch||1.0) : 1.0;
    const rate = script ? (script.rate||1.0) : 1.0;
    await playSequence(seq, rate, pitch);
  });

  // Loop controls
  document.getElementById('startLoopBtn').addEventListener('click', async ()=>{
    if(!audioEnabled){ alert('Tap "Enable audio" first (Safari requires a user gesture).'); return; }
    startGuessLoop();
  });
  document.getElementById('stopLoopBtn').addEventListener('click', ()=> stopGuessLoop());

  // Correct/Incorrect/save label
  document.getElementById('correctBtn').addEventListener('click', ()=>{ savePoints(loadPoints()+1); alert('Point awarded! Total: ' + loadPoints()); });
  document.getElementById('incorrectBtn').addEventListener('click', ()=>{ document.getElementById('labelSaveArea').classList.remove('hidden'); });
  document.getElementById('cancelSaveBtn').addEventListener('click', ()=>{ document.getElementById('labelSaveArea').classList.add('hidden'); document.getElementById('correctLabelInput').value=''; });
  document.getElementById('saveLabelBtn').addEventListener('click', ()=> {
    const label = (document.getElementById('correctLabelInput').value||'').trim();
    if(!label){ alert('Enter label'); return; }
    if(!currentImageEl){ alert('No image'); return; }
    const canvas = document.createElement('canvas'); canvas.width = currentImageEl.naturalWidth; canvas.height = currentImageEl.naturalHeight;
    const ctx = canvas.getContext('2d'); ctx.drawImage(currentImageEl, 0, 0);
    const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
    const ds = loadDataset();
    if(!ds[label]) ds[label] = [];
    ds[label].push({data: dataUrl, t: Date.now()});
    saveDataset(ds);
    alert('Saved labeled image under: ' + label);
    document.getElementById('labelSaveArea').classList.add('hidden');
    document.getElementById('correctLabelInput').value = '';
  });

  // Video preview + extraction
  const videoInput = document.getElementById('videoInput');
  const videoPlayer = document.getElementById('videoPlayer');
  videoInput.addEventListener('change', (ev)=>{
    const f = ev.target.files && ev.target.files[0]; if(!f) return;
    videoPlayer.src = URL.createObjectURL(f);
    videoPlayer.style.display = 'block';
    document.getElementById('extractStatus').textContent = 'Video loaded. Choose start/end and click Extract.';
  });

  // Audio fallback upload handling
  document.getElementById('audioInput').addEventListener('change', async (ev)=>{
    const f = ev.target.files && ev.target.files[0]; if(!f) return;
    try {
      document.getElementById('extractStatus').textContent = 'Decoding audio...';
      const audioBuffer = await decodeAudioFileToBuffer(f);
      // create blob URL for playback: convert file to dataURL
      const reader = new FileReader();
      reader.onload = async (e) => {
        const dataUrl = e.target.result;
        const name = 'audio_clip_' + Date.now();
        const clips = loadClips(); clips[name] = dataUrl; saveClips(clips);
        refreshClipList();
        // estimate pitch
        let pitchHz = null;
        try { pitchHz = await estimatePitchFromAudioBuffer(audioBuffer); } catch(e){ console.warn(e); }
        let suggestedPitch = 1.0, suggestedRate = 1.0;
        if(pitchHz && pitchHz>0){
          const p = Math.max(80, Math.min(400, pitchHz));
          const norm = (p - 100) / (300 - 100);
          suggestedPitch = 0.8 + Math.max(0, Math.min(1, norm)) * 0.7;
          suggestedRate = 0.9 + Math.max(0, Math.min(1, norm)) * 0.3;
        }
        document.getElementById('vmPitch').value = (Math.round(suggestedPitch*10)/10).toFixed(1);
        document.getElementById('vmRate').value = (Math.round(suggestedRate*10)/10).toFixed(1);
        document.getElementById('extractStatus').textContent = `Saved clip "${name}". Suggested pitch=${document.getElementById('vmPitch').value}, rate=${document.getElementById('vmRate').value}.`;
        const scripts = loadScripts();
        if(!scripts['VideoVoice']){ scripts['VideoVoice'] = { templates: [`{clip:${name}} I think this is {label}.`], pitch: suggestedPitch, rate: suggestedRate }; saveScripts(scripts); populateUI(); }
      };
      reader.readAsDataURL(f);
    } catch(err){
      console.error(err);
      document.getElementById('extractStatus').textContent = 'Audio decode failed.';
      alert('Audio decode failed: ' + (err.message || err));
    }
  });

  // preview segment
  document.getElementById('previewSegBtn').addEventListener('click', ()=>{
    const s = parseFloat(document.getElementById('segStart').value || 0);
    const e = parseFloat(document.getElementById('segEnd').value || 0);
    if(!videoPlayer.src){ alert('No video loaded'); return; }
    if(isNaN(s) || isNaN(e) || e<=s){ alert('Invalid times'); return; }
    videoPlayer.currentTime = s;
    videoPlayer.play();
    const stopFn = ()=> { if(videoPlayer.currentTime >= e - 0.05){ videoPlayer.pause(); videoPlayer.removeEventListener('timeupdate', stopFn); } };
    videoPlayer.addEventListener('timeupdate', stopFn);
  });

  // extract (video capture path or fallback)
  document.getElementById('extractClipBtn').addEventListener('click', async ()=>{
    try {
      const s = parseFloat(document.getElementById('segStart').value || 0);
      const e = parseFloat(document.getElementById('segEnd').value || 0);
      if(!videoPlayer.src && !document.getElementById('audioInput').files.length){ alert('Load a video or audio file first'); return; }
      if(isNaN(s) || isNaN(e) || e<=s){ alert('Invalid start/end'); return; }
      document.getElementById('extractStatus').textContent = 'Extracting audio...';
      let res;
      try {
        res = await extractAudioFromVideoSegment(videoPlayer, s, e);
      } catch(err){
        // extraction failed (likely Safari): instruct user to upload audio file as fallback
        document.getElementById('extractStatus').textContent = 'Video extraction unsupported — use audio upload.';
        alert('Video extraction not supported in this browser. Upload a short audio clip in “Audio fallback” to use as the voice clip.');
        return;
      }
      const name = 'video_clip_' + Date.now();
      const clips = loadClips(); clips[name] = res.dataUrl; saveClips(clips); refreshClipList();
      let pitchHz = null;
      try { pitchHz = await estimatePitchFromAudioBuffer(res.audioBuffer); } catch(e){ console.warn(e); }
      let suggestedPitch = 1.0, suggestedRate = 1.0;
      if(pitchHz && pitchHz>0){
        const p = Math.max(80, Math.min(400, pitchHz));
        const norm = (p - 100) / (300 - 100);
        suggestedPitch = 0.8 + Math.max(0, Math.min(1, norm)) * 0.7;
        suggestedRate = 0.9 + Math.max(0, Math.min(1, norm)) * 0.3;
      }
      document.getElementById('vmPitch').value = (Math.round(suggestedPitch*10)/10).toFixed(1);
      document.getElementById('vmRate').value = (Math.round(suggestedRate*10)/10).toFixed(1);
      document.getElementById('extractStatus').textContent = `Saved clip "${name}". Suggested pitch=${document.getElementById('vmPitch').value}, rate=${document.getElementById('vmRate').value}.`;
      const scripts = loadScripts();
      if(!scripts['VideoVoice']){ scripts['VideoVoice'] = { templates: [`{clip:${name}} I think this is {label}.`], pitch: suggestedPitch, rate: suggestedRate }; saveScripts(scripts); populateUI(); }
    } catch(err){
      console.error(err);
      alert('Extraction failed: ' + (err.message || err));
      document.getElementById('extractStatus').textContent = 'Extraction failed.';
    }
  });

  // Voice maker handlers
  document.getElementById('vmScriptList').addEventListener('change', loadScriptEditor);
  document.getElementById('vmSave').addEventListener('click', ()=>{
    const name = (document.getElementById('vmName').value||'').trim();
    if(!name){ alert('Provide name'); return; }
    const templates = (document.getElementById('vmTemplates').value || '').split('\n').map(s=>s.trim()).filter(Boolean);
    if(templates.length === 0){ alert('Add at least one template line'); return; }
    const pitch = parseFloat(document.getElementById('vmPitch').value) || 1.0;
    const rate = parseFloat(document.getElementById('vmRate').value) || 1.0;
    const scripts = loadScripts(); scripts[name] = { templates, pitch, rate }; saveScripts(scripts); populateUI(); alert('Saved script: ' + name);
  });
  document.getElementById('vmNew').addEventListener('click', ()=>{ document.getElementById('vmName').value='NewScript'; document.getElementById('vmTemplates').value='I think this is {label}.'; document.getElementById('vmPitch').value='1.0'; document.getElementById('vmRate').value='1.0'; });
  document.getElementById('vmDelete').addEventListener('click', ()=>{ const name=(document.getElementById('vmScriptList').value||'').trim(); if(!name) return; if(!confirm('Delete script "'+name+'"?')) return; const scripts = loadScripts(); delete scripts[name]; saveScripts(scripts); populateUI(); alert('Deleted ' + name); });

  // initial populate
  populateUI();
});
</script>
</body>
</html>
