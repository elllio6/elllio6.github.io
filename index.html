<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FunnyImageAI — Maxed Predictions & Simple Controls</title>

  <!-- TensorFlow.js + MobileNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.2.1/dist/mobilenet.min.js"></script>

  <style>
    :root {
      --accent: #0b6df2;
      --muted: #6b7280;
      --bg: #f6f9ff;
      --card: #fff;
      --radius: 10px;
    }
    html,body { height:100%; margin:0; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial; background:var(--bg); color:#0f172a; }
    .wrap { max-width:1000px; margin:20px auto; padding:16px; }
    header { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px; }
    h1 { margin:0; font-size:1.15rem; }
    .muted { color:var(--muted); font-size:0.92rem; }
    .card { background:var(--card); border-radius:10px; padding:14px; box-shadow:0 8px 20px rgba(12,18,36,0.06); margin-bottom:12px; }
    .uploader { display:flex; gap:8px; align-items:center; }
    input[type="file"] { display:none; }
    button { padding:8px 12px; border-radius:8px; border:0; background:var(--accent); color:#fff; cursor:pointer; }
    button.ghost { background:transparent; color:var(--accent); border:1px solid var(--accent); }
    button.secondary { background:#6b7280; }
    img.preview { display:block; max-width:100%; border-radius:8px; margin-top:10px; }
    .small { font-size:0.9rem; color:var(--muted); }
    .pred-list { list-style:none; padding:0; margin:8px 0; }
    .pred-list li { padding:8px; border-bottom:1px dashed #eef4ff; cursor:pointer; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .inline { display:inline-flex; gap:8px; align-items:center; }
    .search { width:100%; padding:8px; border-radius:8px; border:1px solid #e6eefc; box-sizing:border-box; margin-top:8px; }
    .muted-block { color:var(--muted); margin-top:8px; }
    footer { margin-top:16px; color:var(--muted); text-align:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>FunnyImageAI — Max Predictions</h1>
        <div class="muted">Model returns up to 1000 ImageNet labels. Use search & "Show more" to explore.</div>
      </div>
      <div style="text-align:right">
        <div class="small">Points: <span id="pointsBadge">0</span></div>
        <div style="margin-top:8px">
          <button id="enableAudioBtn" class="ghost">Enable audio</button>
          <div id="audioStatus" class="small" style="margin-top:6px">Audio: not enabled</div>
        </div>
      </div>
    </header>

    <div class="card">
      <label style="font-weight:700">Image (single)</label>
      <div class="uploader">
        <input id="imageInput" type="file" accept="image/*">
        <button id="chooseImage" class="ghost">Choose image</button>
        <div class="small">Pick an image. Model will request the full set of ImageNet labels (1000).</div>
      </div>
      <img id="preview" class="preview" style="display:none" alt="preview">

      <div id="modelStatus" class="small" style="margin-top:10px">Model: loading...</div>

      <div id="resultsCard" style="display:none; margin-top:12px">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="searchInput" class="search" placeholder="Filter predictions (type to search) — click a label to speak it">
        </div>

        <div class="muted-block">Showing <span id="shownCount">0</span> of <span id="totalCount">0</span> labels</div>

        <ul id="predList" class="pred-list"></ul>

        <div class="controls" style="margin-top:10px">
          <button id="showMoreBtn" class="ghost">Show more</button>
          <button id="speakTopBtn" class="ghost">Speak top</button>
          <div class="inline">
            <button id="startLoopBtn">Start auto</button>
            <button id="stopLoopBtn" class="ghost" style="display:none">Stop</button>
            <div class="small">Delay</div>
            <input id="minDelay" type="number" value="2" min="1" style="width:60px">
            <div class="small">to</div>
            <input id="maxDelay" type="number" value="5" min="1" style="width:60px">
          </div>
        </div>

        <div style="margin-top:12px" class="small muted">
          Tip: use the search box to find any label quickly (substring match). You can also add custom labels below to include in auto-guess pool.
        </div>

        <div style="margin-top:12px">
          <input id="customLabelInput" placeholder="Add custom label (press Add)" style="padding:8px;border-radius:8px;border:1px solid #e6eefc">
          <button id="addCustomBtn" class="ghost">Add</button>
          <div class="small muted" style="margin-top:6px">Custom labels are saved in your browser and included in auto-guess pool.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <label style="font-weight:700">Audio clip (optional)</label>
      <input id="audioInput" type="file" accept="audio/*">
      <div id="audioStatusText" class="small" style="margin-top:8px"></div>
    </div>

    <footer>
      Hosting & persistence: GitHub Pages (free) or Cloudflare Pages, Netlify, Vercel — all can host this static site and serve it indefinitely. See notes below.
    </footer>
  </div>

<script>
/* Maxed predictions + simple UI
   - MODEL_TOPK = 1000 to return all ImageNet labels
   - Search box to filter; "Show more" lazy-load for performance
   - Add custom labels stored in localStorage and included in auto-guess pool
   - Simple TTS with "Enable audio" gesture for Safari
*/

const MODEL_TOPK = 1000; // request the full ImageNet label set from MobileNet
const INITIAL_SHOW = 50; // number of labels shown initially; "Show more" adds this many

// DOM
const chooseImageBtn = document.getElementById('chooseImage');
const imageInput = document.getElementById('imageInput');
const previewImg = document.getElementById('preview');
const modelStatus = document.getElementById('modelStatus');
const resultsCard = document.getElementById('resultsCard');
const predList = document.getElementById('predList');
const searchInput = document.getElementById('searchInput');
const showMoreBtn = document.getElementById('showMoreBtn');
const shownCountSpan = document.getElementById('shownCount');
const totalCountSpan = document.getElementById('totalCount');
const speakTopBtn = document.getElementById('speakTopBtn');
const enableAudioBtn = document.getElementById('enableAudioBtn');
const audioStatus = document.getElementById('audioStatus');
const audioInput = document.getElementById('audioInput');
const audioStatusText = document.getElementById('audioStatusText');
const addCustomBtn = document.getElementById('addCustomBtn');
const customLabelInput = document.getElementById('customLabelInput');

const startLoopBtn = document.getElementById('startLoopBtn');
const stopLoopBtn = document.getElementById('stopLoopBtn');
const minDelayInput = document.getElementById('minDelay');
const maxDelayInput = document.getElementById('maxDelay');

const STORAGE_CUSTOM = 'funny_custom_labels_v1';
const STORAGE_CLIPS = 'funny_clips_v1';

let net = null;
let audioEnabled = false;
let AVAILABLE_VOICES = [];
let allPredictions = []; // array of [label, score]
let filteredPredictions = []; // after search filter
let showCount = INITIAL_SHOW;
let autoRunning = false;
let pool = [];
let poolIndex = 0;
let lastGuessed = null;

// --- Model load ---
async function loadModel(){
  modelStatus.textContent = 'Model: loading...';
  try {
    net = await mobilenet.load({version:2, alpha:1.0});
    modelStatus.textContent = 'Model: ready';
  } catch(err){
    modelStatus.textContent = 'Model failed to load';
    console.error(err);
  }
}

// --- Audio / TTS ---
function ensureVoicesLoaded(timeout = 1500){
  return new Promise(resolve => {
    const v = window.speechSynthesis.getVoices();
    if(v && v.length){ AVAILABLE_VOICES = v; return resolve(v); }
    const onv = () => { const vv = window.speechSynthesis.getVoices(); AVAILABLE_VOICES = vv; window.speechSynthesis.removeEventListener('voiceschanged', onv); resolve(vv); };
    window.speechSynthesis.addEventListener('voiceschanged', onv);
    setTimeout(()=>{ const vv = window.speechSynthesis.getVoices() || []; AVAILABLE_VOICES = vv; window.speechSynthesis.removeEventListener('voiceschanged', onv); resolve(vv); }, timeout);
  });
}
function pickVoice(){
  for(const v of AVAILABLE_VOICES){ if(/en/i.test(v.lang) || /english/i.test(v.name)) return v; }
  return AVAILABLE_VOICES[0] || null;
}
async function speakText(text, rate=1.0, pitch=1.0){
  if(!audioEnabled) return;
  if(!('speechSynthesis' in window)) return;
  await ensureVoicesLoaded();
  return new Promise(resolve => {
    try {
      const u = new SpeechSynthesisUtterance(String(text));
      u.rate = rate; u.pitch = pitch;
      const v = pickVoice(); if(v) u.voice = v;
      u.onend = () => resolve();
      u.onerror = () => resolve();
      window.speechSynthesis.speak(u);
    } catch(e){
      console.warn(e); resolve();
    }
  });
}

// --- Helpers for predictions UI ---
function renderList(){
  predList.innerHTML = '';
  const list = filteredPredictions.slice(0, showCount);
  for(const [label, score] of list){
    const li = document.createElement('li');
    li.innerHTML = `<strong>${escapeHtml(label)}</strong> — ${(score*100).toFixed(1)}%`;
    li.addEventListener('click', async () => {
      if(!audioEnabled){ alert('Tap "Enable audio" first to hear speech in Safari.'); return; }
      await speakText(label);
    });
    predList.appendChild(li);
  }
  shownCountSpan.textContent = Math.min(filteredPredictions.length, showCount);
  totalCountSpan.textContent = filteredPredictions.length;
  showMoreBtn.style.display = filteredPredictions.length > showCount ? '' : 'none';
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// --- Classify file and populate allPredictions ---
async function classifyFile(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.src = url;
  await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });
  previewImg.src = img.src; previewImg.style.display = '';
  if(!net) await loadModel();
  modelStatus.textContent = 'Classifying (may take a moment)...';
  // request the full set of ImageNet labels
  let results = [];
  try {
    results = await net.classify(img, MODEL_TOPK);
  } catch(err){
    console.error('classify error', err);
    modelStatus.textContent = 'Classification error';
    alert('Classification failed: ' + (err.message || err));
    return;
  }
  modelStatus.textContent = 'Ready';
  // results: [{className, probability}, ...]
  allPredictions = results.map(r => [r.className, r.probability || 0]);
  // mix in custom labels (score 0) so they appear in list and pool
  const custom = loadCustomLabels();
  for(const c of custom){
    // avoid duplicates (case-insensitive)
    if(!allPredictions.some(p => p[0].toLowerCase() === c.toLowerCase())){
      allPredictions.push([c, 0]);
    }
  }
  // apply a little variety if desired
  allPredictions = applySmallBadness(allPredictions);
  // initial filtered view is full list
  filteredPredictions = allPredictions.slice();
  showCount = INITIAL_SHOW;
  renderList();
  resultsCard.style.display = '';
}

// --- Search/filter ---
searchInput.addEventListener('input', () => {
  const q = (searchInput.value || '').trim().toLowerCase();
  if(!q){ filteredPredictions = allPredictions.slice(); }
  else {
    filteredPredictions = allPredictions.filter(p => p[0].toLowerCase().includes(q));
  }
  showCount = INITIAL_SHOW;
  renderList();
});

// --- Show more ---
showMoreBtn.addEventListener('click', () => {
  showCount += INITIAL_SHOW;
  renderList();
});

// --- Speak top ---
speakTopBtn.addEventListener('click', async () => {
  if(!allPredictions.length){ alert('Upload an image first'); return; }
  if(!audioEnabled){ alert('Enable audio first'); return; }
  const top = allPredictions[0][0];
  await speakText(top);
});

// --- Enable audio ---
enableAudioBtn.addEventListener('click', async () => {
  audioEnabled = true;
  audioStatus.textContent = 'Audio: enabled';
  await ensureVoicesLoaded();
  try { await speakText('Audio enabled'); } catch(e){ /* ignore */ }
});

// --- Custom labels (persisted) ---
function loadCustomLabels(){ try { return JSON.parse(localStorage.getItem(STORAGE_CUSTOM) || '[]'); } catch(e){ return []; } }
function saveCustomLabels(arr){ localStorage.setItem(STORAGE_CUSTOM, JSON.stringify(arr)); }

addCustomBtn.addEventListener('click', () => {
  const v = (customLabelInput.value || '').trim();
  if(!v){ alert('Enter a label'); return; }
  const arr = loadCustomLabels();
  if(arr.some(x => x.toLowerCase() === v.toLowerCase())){ alert('Label already added'); return; }
  arr.push(v);
  saveCustomLabels(arr);
  customLabelInput.value = '';
  alert('Custom label added (will appear with next classification).');
});

// --- Auto-guess loop ---
function buildPool(){
  const commons = ["banana","chair","shoe","cat","dog","tree","car","clock","bottle","cup","box","phone","book","person","building","flower","plant","hat","suitcase"];
  const labels = allPredictions.map(p => p[0]);
  const merged = labels.slice();
  for(const c of commons){ if(!merged.includes(c) && merged.length < 2000) merged.push(c); }
  return shuffle(merged);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

startLoopBtn.addEventListener('click', async () => {
  if(!allPredictions.length){ alert('Upload an image first'); return; }
  if(!audioEnabled){ alert('Enable audio first'); return; }
  if(autoRunning) return;
  pool = buildPool();
  poolIndex = 0;
  autoRunning = true;
  startLoopBtn.style.display = 'none';
  stopLoopBtn.style.display = '';
  document.getElementById('loopStatus').textContent = 'Running';
  while(autoRunning){
    if(poolIndex >= pool.length) { pool = shuffle(pool.slice()); poolIndex = 0; }
    let label = pool[poolIndex++];
    if(label === lastGuessed && pool.length > 1) label = pool[poolIndex++ % pool.length];
    lastGuessed = label;
    const text = `I think this might be ${label}.`;
    await speakText(text);
    if(!autoRunning) break;
    const minD = Math.max(1, Number(minDelayInput.value) || 2);
    const maxD = Math.max(minD, Number(maxDelayInput.value) || 5);
    const delay = minD + Math.random()*(maxD - minD);
    const start = Date.now();
    while(autoRunning && Date.now() - start < delay*1000) await new Promise(r => setTimeout(r, 200));
  }
  autoRunning = false;
  startLoopBtn.style.display = '';
  stopLoopBtn.style.display = 'none';
  document.getElementById('loopStatus').textContent = 'Stopped';
});
stopLoopBtn.addEventListener('click', () => { autoRunning = false; });

// --- Audio clip storage (simple) ---
function loadClips(){ try { return JSON.parse(localStorage.getItem(STORAGE_CLIPS) || '{}'); } catch(e){ return {}; } }
function saveClips(obj){ localStorage.setItem(STORAGE_CLIPS, JSON.stringify(obj)); }

// --- Audio upload decoding (small) ---
audioInput.addEventListener('change', async (ev) => {
  const f = ev.target.files && ev.target.files[0]; if(!f) return;
  audioStatusText.textContent = 'Decoding...';
  try {
    const arr = await f.arrayBuffer();
    const actx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = await actx.decodeAudioData(arr.slice(0));
    const blob = audioBufferToWavBlob(buf);
    const url = await blobToDataURL(blob);
    const name = (f.name || 'audio') + '_' + Date.now();
    const clips = loadClips(); clips[name] = url; saveClips(clips); audioStatusText.textContent = `Saved clip "${name}"`;
  } catch(err){
    console.error(err); audioStatusText.textContent = 'Audio decode failed'; alert('Audio decode failed: ' + (err.message||err));
  }
});

// --- Utility audio helpers ---
function audioBufferToWavBlob(buffer){
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const length = buffer.length * numChannels * 2 + 44;
  const ab = new ArrayBuffer(length);
  const view = new DataView(ab);
  let offset = 0;
  function writeString(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
  writeString('RIFF'); view.setUint32(offset, 36 + buffer.length * numChannels * 2, true); offset += 4;
  writeString('WAVE'); writeString('fmt '); view.setUint32(offset, 16, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2;
  view.setUint16(offset, numChannels, true); offset += 2;
  view.setUint32(offset, sampleRate, true); offset += 4;
  view.setUint32(offset, sampleRate * numChannels * 2, true); offset += 4;
  view.setUint16(offset, numChannels * 2, true); offset += 2;
  view.setUint16(offset, 16, true); offset += 2;
  writeString('data'); view.setUint32(offset, buffer.length * numChannels * 2, true); offset += 4;
  for(let i=0;i<buffer.length;i++){
    for(let ch=0; ch<numChannels; ch++){
      let sample = buffer.getChannelData(ch)[i];
      sample = Math.max(-1, Math.min(1, sample));
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      offset += 2;
    }
  }
  return new Blob([view], {type:'audio/wav'});
}
function blobToDataURL(blob){ return new Promise((res,rej) => { const fr = new FileReader(); fr.onload = ()=>res(fr.result); fr.onerror = rej; fr.readAsDataURL(blob); }); }

// --- small playful badness used earlier ---
function applySmallBadness(preds){ 
  const commons = ["banana","chair","shoe","cat","dog","tree","car"];
  let out = preds.map(p => [p[0], Math.max(0.01, p[1] * 0.6)]);
  if(Math.random() < 0.25) out.unshift([commons[Math.floor(Math.random()*commons.length)], 0.08]);
  return out;
}

// --- initialization ---
(async function init(){
  if(!localStorage.getItem(STORAGE_CUSTOM)) localStorage.setItem(STORAGE_CUSTOM, JSON.stringify([]));
  await loadModel();
  // wire choose image button
  chooseImageBtn.addEventListener('click', () => imageInput.click());
  imageInput.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0]; if(!f) return;
    await classifyFile(f);
  });
})();
</script>
</body>
</html>
